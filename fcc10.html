<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

</body>
<script>
  //1.反转字符串
  const rever = str => str.split('').reduce((res, cur) => cur + res)
  // console.log(rever('abcd'))

  //2.回文
  const isPalindrome = str => {
    return rever(str) === str
  }
  // console.log(isPalindrome('eyaye'))

  //3.整数反转
  const IntegerReversal = num => parseInt(num.toString().split('').reverse().join('')) * Math.sign(num)
  // console.log(IntegerReversal(1234))

  //4.记录出现最多的字符
  const maxWord = str => {
    const obj = {}
    let max = 0
    let character = ''
    for (const val of str) {
      obj[val] = obj[val] + 1 || 1
    }
    for (let key of Object.keys(obj)) {
      if (obj[key] > max) {
        max = obj[key]
        character = key
      }
    }
    return character
  }
  // console.log(maxWord('shdgsjdbkskssssss'))

  //5.元音字母字数
  const aeuio = str => {
    let match = str.match(/[aeuio]/gi)
    return match && match.length || 0
  }
  // console.log(aeuio('qqqqqqq'))

  //6.数组拆分
  const chunk = (arr, size) => {
    let res = []
    for (i = 0; i < arr.length; i += size) {
      res.push(arr.slice(i, i + size))
    }
    return res
  }
  // console.log(chunk([1,2,3,4,5,6,7,8,9,0],9))

  //7.反转单词
  const reverseWord = str => str.split(' ').map(word => word.split('').reverse().join('')).join(' ')
  // console.log(reverseWord('fuck tr and vs'))


  Function.prototype.myCall = function (ctx, ...args) {
    const fn = Symbol('临时属性')
    ctx[fn] = this // obj[x] = test
    ctx[fn](...args) //  obj.test()
    delete ctx[fn] //
  }


  Function.prototype.myBind = function (ctx, ...args) {
    let that = this
    const bindFn = function (..._args) {
      const isNew = this instanceof bindFn //this 是否是 bindFn 的实例，也就是 new 调用
      const _ctx = isNew ? this : ctx // new 调用就绑定到 this 上,否则就绑定到传入的 ctx 上
      that.myCall(_ctx, ...args, ..._args)
    }
    bindFn.prototype = Object.create(that.prototype) // 复制源函数的 prototype 给新返回的函数
    return bindFn
  }

  const intersectionOfMultiArray = (...arr) => {
    if(arr.length < 2) return arr[0]
    return arr.reduce((prev, curr) => {
      return prev.filter(item => curr.includes(item))
    })
  }
  console.log(intersectionOfMultiArray([1, 2, 3, 8], [2, 3, 4, 8], [3, 8]))
</script>

</html>