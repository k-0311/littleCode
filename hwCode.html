<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body></body>
  <script>
    Function.prototype.myCall = function (ctx, ...args) {
      if (typeof this !== 'function') throw new TypeError('Error')
      const fn = Symbol('临时属性')
      ctx[fn] = this // obj[x] = test
      ctx[fn](...args) //  obj.test()
      delete ctx[fn] //
    }

    Function.prototype.myApply = function (ctx, args) {
      if (typeof this !== 'function') throw new TypeError('Error')
      const fn = Symbol('临时属性')
      ctx[fn] = this // obj[x] = test
      ctx[fn](...args) //  obj.test()
      delete ctx[fn] //
    }

    Function.prototype.myBind = function (ctx, ...args) {
      if (typeof this !== 'function') throw new TypeError('Error')
      let that = this
      const bindFn = function (..._args) {
        const isNew = this instanceof bindFn //this 是否是 bindFn 的实例，也就是 new 调用
        const _ctx = isNew ? this : ctx // new 调用就绑定到 this 上,否则就绑定到传入的 ctx 上
        that.myCall(_ctx, ...args, ..._args)
      }
      bindFn.prototype = Object.create(that.prototype) // 复制源函数的 prototype 给新返回的函数
      return bindFn
    }

    function myNew(fn, ...args) {
      const obj = {} //创建一个全新的对象
      fn.myCall(obj, ...args) //this 指向新创建的对象
      obj.__proto__ = fn.prototype //隐藏属性 链接到这个函数的 prototype 对象
      return obj
    }

    function myInstanceof(L, R) {
      if (!L || !L.__proto__ || !R || !R.prototype) return false
      while (L) {
        if (L.__proto__ === R.prototype) return true
        L = L.__proto__
      }
      return false
    }

    function mySetInterval() {
      mySetInterval.timer = setTimeout(() => {
        arguments[0]()
        mySetInterval(...arguments)
      }, arguments[1])
    }
    mySetInterval.clear = function () {
      clearTimeout(mySetInterval.timer)
    }
  </script>
  <script>
    class EventEmitter {
      constructor() {
        this._events = {}
      }

      on(eventName, callback) {
        if (this._events[eventName]) {
          if (this.eventName !== 'newListener') {
            this.emit('newListener', eventName)
          }
        }
        const callbacks = this._events[eventName] || []
        callbacks.push(callback)
        this._events[eventName] = callbacks
      }

      emit(eventName, ...args) {
        const callbacks = this._events[eventName] || []
        callbacks.forEach(cb => cb(...args))
      }

      once(eventName, callback) {
        const one = (...args) => {
          callback(...args)
          this.off(eventName, one)
        }
        one.initialCallback = callback
        this.on(eventName, one)
      }

      off(eventName, callback) {
        const callbacks = this._events[eventName] || []
        const newCallbacks = callbacks.filter(
          fn =>
            fn != callback &&
            fn.initialCallback != callback /* 用于once的取消订阅 */
        )
        this._events[eventName] = newCallbacks
      }
    }
  </script>
</html>
